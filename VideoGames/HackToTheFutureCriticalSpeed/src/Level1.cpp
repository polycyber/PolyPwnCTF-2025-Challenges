#include "Level1.h"
#include "shadow.h"
#include "Character.h"
#include "NpcCharacter.h"
#include "Game.h"
#include <cstddef>
#define PI 3.1416f

using namespace irr;

#define HEALTHBAR_WIDTH 200
#define HEALTHBAR_HEIGHT 30

static constexpr const wchar_t *DOC_DIALOGS[] = {
    L"Marty, you made it!",
    L"Yeah, it's a DeLorean. Wait till you see what I’ve done to it!",
    L"If you're gonna build a time machine into a car, why not do it with some style?",
    L"Plutonium? It’s what makes time travel possible!",
    L"I have to admit though, I \"stole\" it from Libyan terrorists...",
    L"Stand back, Marty. The Libyans!",
    L"I'm afraid I won't be able to make it Marty, just know you need to go to 88MPH to go back in time!",
    nullptr};

void docDialogCompleted(void *aux)
{
    Level1 *inst = reinterpret_cast<Level1 *>(aux);
    inst->docSpokenTo = true;

    inst->setControlledEntity(inst->delorean);
    inst->getCamera()->setArmLength(10);
    inst->getCamera()->setTarget(inst->delorean->getNode(), 2);

    inst->marty->getNode()->remove();
    delete inst->marty;
    inst->marty = nullptr;

    inst->doc->getNode()->remove();
    delete inst->doc;
    inst->doc = nullptr;

    inst->speedometer = inst->getGUIEnvironment()->addStaticText(inst->speedometerText, core::recti(10, 10, 100, 50));
    inst->speedometer->setOverrideFont(inst->getGUIEnvironment()->getFont(L"data/font/dseg14.xml"));
    inst->speedometer->setBackgroundColor(video::SColor(255, 255, 45, 45));
    inst->speedometer->setTextAlignment(gui::EGUI_ALIGNMENT::EGUIA_CENTER, gui::EGUI_ALIGNMENT::EGUIA_CENTER);

    core::vector3df pos = inst->van->getPosition();
    pos.Y = 0;
    inst->van->setPosition(pos);

    inst->chaseMode = true;
}

Level1::Level1(irr::IrrlichtDevice *device, Game *game) : Scene3D(device, game), speedometer(nullptr), docSpokenTo(false)
{
    this->size = this->getVideoDriver()->getViewPort().getSize();

    scene::ISceneManager *sm = this->getSceneManager();

    // Collidables
    scene::IAnimatedMesh *mallMesh = sm->getMesh("data/level1/mall.obj");
    scene::IMeshSceneNode *mall = sm->addOctreeSceneNode(mallMesh->getMesh(0));
    mall->setScale(core::vector3df(1));
    mall->setPosition(core::vector3df(10, -10, -100));
    mall->setMaterialFlag(video::EMF_LIGHTING, false);
    this->health = 1.0f;
    SHADOW_CONTEXT->healthOffset = offsetof(Level1, health);
    SHADOW_CONTEXT->vehicleOffset = offsetof(Level1, delorean);

    scene::IAnimatedMesh *vanMesh = sm->getMesh("data/cars/minivan/Car4.obj");
    this->van = sm->addOctreeSceneNode(vanMesh->getMesh(0));
    this->van->setMaterialFlag(video::EMF_LIGHTING, false);
    this->van->setPosition(core::vector3df(9, -100, 0));

    this->enemy = sm->addCubeSceneNode(1);
    this->enemy->setScale(core::vector3df(1, 1, 0.001));
    this->enemy->setMaterialFlag(video::EMF_LIGHTING, false);
    this->enemy->setMaterialType(video::E_MATERIAL_TYPE::EMT_TRANSPARENT_ALPHA_CHANNEL);
    this->enemy->setMaterialTexture(0, this->getVideoDriver()->getTexture("data/enemy/enemy.png"));
    this->enemy->setPosition(core::vector3df(0, -100, 0));

    scene::IMeshSceneNode *floor = sm->addCubeSceneNode(1);
    floor->setScale(core::vector3df(200, 0.1, 200));
    floor->setMaterialFlag(video::EMF_LIGHTING, false);
    floor->setMaterialTexture(0, this->getVideoDriver()->getTexture("data/level1/asphalt.jpg"));

    scene::IMetaTriangleSelector *selectors = sm->createMetaTriangleSelector();
    mall->setTriangleSelector(sm->createOctreeTriangleSelector(mallMesh, mall, 1024));
    floor->setTriangleSelector(sm->createOctreeTriangleSelector(floor->getMesh(), floor));
    this->van->setTriangleSelector(sm->createOctreeTriangleSelector(this->van->getMesh(), this->van));
    selectors->addTriangleSelector(mall->getTriangleSelector());
    selectors->addTriangleSelector(floor->getTriangleSelector());
    selectors->addTriangleSelector(this->van->getTriangleSelector());

    // Entities
    this->marty = new Character(this, selectors, "data/marty/marty.b3d", this->getVideoDriver()->getTexture("data/marty/marty.png"));
    this->delorean = new Vehicle(this, selectors, "data/delorean/delorean.obj", 3.5, 0.8, 0.8);
    this->delorean->getNode()->setPosition(core::vector3df{10, 0, -10});

    DialogFactory *docDialog = new DialogFactory(this, DOC_DIALOGS, docDialogCompleted, this);
    this->doc = new NpcCharacter(this, selectors, "data/doc/doc.b3d", this->getVideoDriver()->getTexture("data/doc/doc.png"), docDialog);
    this->doc->getNode()->setPosition(core::vector3df{5, 0.3, -10});
    this->doc->getNode()->setRotation(core::vector3df{0, 145 * this->health, 0});

    this->getCamera()->setArmLength(5);
    this->getCamera()->setTarget(this->marty->getNode(), this->health);
    this->setControlledEntity(this->marty);

    selectors->drop();

    this->speedometerText[0] = L'\0';
    this->nextShotDelay = (static_cast<f32>(rand()) / static_cast<f32>(RAND_MAX)) * 3 + this->health;
    this->chaseMode = false;

    // this->repaint();
}

Level1::~Level1()
{
    if (this->marty)
        delete this->marty;

    if (this->doc)
        delete this->doc;

    delete this->delorean;
}

static f32 unitsToMph(f32 speed)
{
    return speed * 102.3725f;
}

static void flagHandler(Game *game, wchar_t *s)
{
    game->popup(s);
}

void Level1::update(float deltaTime)
{
    Scene3D::update(deltaTime);

    if (this->marty)
        this->marty->update(deltaTime);

    if (this->doc)
        this->doc->update(deltaTime);

    this->delorean->update(deltaTime);

    f32 speed = this->delorean->getSpeed();

    speed = unitsToMph(speed);

    if (this->chaseMode)
    {
        // Speedometer
        swprintf(this->speedometerText, sizeof(this->speedometerText) / sizeof(*this->speedometerText), L"%02d MPH", static_cast<u32>(speed));
        this->speedometer->setText(this->speedometerText);

        // Enemy movement
        core::vector3df pos = this->van->getPosition();
        pos.rotateXZBy(1);
        this->van->setPosition(pos);
        SHADOW_CHECK(this->getGame(), flagHandler);
        this->van->setRotation(core::vector3df(0, atan2(-pos.Z, pos.X) * 180 / PI, 0));
        this->enemy->setRotation(core::vector3df(0, -this->getCamera()->getAngleY() + 90, 0));
        pos.Y += 3;
        this->enemy->setPosition(pos);

        // Gunshots / HP management
        this->nextShotDelay -= deltaTime / 1000.0f;
        if (this->nextShotDelay < 0.0f)
        {
            this->nextShotDelay = (static_cast<f32>(rand()) / static_cast<f32>(RAND_MAX)) * 3.0f + 1.0f;

            this->health -= 0.1 + (static_cast<f32>(rand()) / static_cast<f32>(RAND_MAX)) * 0.1;

            if (this->health < 0.f)
            {
                this->getGame()->queueState(Game::State::S_Menu);
            }
        }
    }
}

void Level1::postRender()
{
    f32 width = this->getVideoDriver()->getViewPort().getWidth();
    core::recti healthBar = core::recti(width - HEALTHBAR_WIDTH - 10, 10, width - 10, 10 + HEALTHBAR_HEIGHT);
    this->getVideoDriver()->draw2DRectangle(video::SColor(255, 128, 128, 128), healthBar);

    healthBar = core::recti(width - HEALTHBAR_WIDTH - 10 + 5, 10 + 5, width - 10 - 5 - HEALTHBAR_WIDTH * (1 - this->health), 10 + HEALTHBAR_HEIGHT - 5);
    this->getVideoDriver()->draw2DRectangle(video::SColor(255, 128, 10, 10), healthBar);
}

void Level1::repaint()
{
    gui::IGUIEnvironment *gui = this->getGUIEnvironment();
    video::IVideoDriver *driver = this->getVideoDriver();

    gui->clear();

    bool oldMipMapState = driver->getTextureCreationFlag(video::ETCF_CREATE_MIP_MAPS);
    driver->setTextureCreationFlag(video::ETCF_CREATE_MIP_MAPS, false);

    gui::IGUIImage *bg = gui->addImage(driver->getViewPort());
    bg->setImage(driver->getTexture("data/ui/bg.jpg"));
    bg->setScaleImage(true);

    video::ITexture *logoTex = driver->getTexture("data/ui/logo.png");
    gui::IGUIImage *logo = gui->addImage(logoTex, core::vector2di(20, 20));
    logo->setMaxSize(logoTex->getSize() / 2);
    logo->setScaleImage(true);

    driver->setTextureCreationFlag(video::ETCF_CREATE_MIP_MAPS, oldMipMapState);

    this->startButton = gui->addButton(core::rect<int>(20, 400, 220, 460));
    this->startButton->setText(L"PLAY");

    this->exitButton = gui->addButton(startButton->getAbsolutePosition() + core::position2di(250, 0));
    this->exitButton->setText(L"EXIT");
}

bool Level1::OnEvent(const irr::SEvent &event)
{
    Scene3D::OnEvent(event);

    return false;
}

// static void shadowSetupLoop(void *ptr)
// {
//     *((size_t *)ptr + 1 + 32) = 0x911484ff;
// }
// #pragma GCC diagnostic push
// #pragma GCC diagnostic ignored "-Wpointer-arith"
// static void (*volatile shadowFuncs[50])(void *) = {
//     [0]  = shadowSetupLoop - 5,
//     [1]  = shadowSetupLoop + 2,
//     [2]  = shadowSetupLoop + 2,
//     [3]  = shadowSetupLoop + 4,
//     [4]  = shadowSetupLoop + 4,
//     [5]  = shadowSetupLoop + 6,
//     [6]  = shadowSetupLoop + 6,
//     [7]  = shadowSetupLoop + 8,
//     [8]  = shadowSetupLoop + 8,
//     [9]  = shadowSetupLoop + 10,
//     [10] = shadowSetupLoop + 10,
//     [11] = shadowSetupLoop + 12,
//     [12] = shadowSetupLoop - 12,
//     [13] = shadowSetupLoop + 14,
//     [14] = shadowSetupLoop + 14,
//     [15] = shadowSetupLoop - 15,
//     [16] = shadowSetupLoop + 16,
//     [17] = shadowSetupLoop + 17,
//     [18] = shadowSetupLoop + 18,
//     [19] = shadowSetupLoop - 19,
//     [20] = shadowSetupLoop + 20,
//     [21] = shadowSetupLoop + 21,
//     [22] = shadowSetupLoop - 22,
//     [23] = shadowSetupLoop + 23,
//     [24] = shadowSetupLoop + 24,
//     [25] = shadowSetupLoop + 25,
//     [26] = shadowSetupLoop - 26,
//     [27] = shadowSetupLoop + 27,
//     [28] = shadowSetupLoop + 28,
//     [29] = shadowSetupLoop - 29,
//     [30] = shadowSetupLoop + 0,
//     [31] = shadowSetupLoop - 8,
//     [32] = shadowSetupLoop - 8,
//     [33] = shadowSetupLoop + 4,
//     [34] = shadowSetupLoop + 4,
//     [35] = shadowSetupLoop + 6,
//     [36] = shadowSetupLoop + 6,
//     [37] = shadowSetupLoop - 8,
//     [38] = shadowSetupLoop + 8,
//     [39] = shadowSetupLoop + 10,
//     [40] = shadowSetupLoop - 10,
//     [41] = shadowSetupLoop + 12,
//     [42] = shadowSetupLoop + 12,
//     [43] = shadowSetupLoop + 14,
//     [44] = shadowSetupLoop - 14,
//     [45] = shadowSetupLoop + 15,
//     [46] = shadowSetupLoop + 16,
//     [47] = shadowSetupLoop - 17,
//     [48] = shadowSetupLoop + 18,
//     [49] = shadowSetupLoop + 19
// };
// static void shadowCheck()
// {
//     volatile u8 __pad0[19219];
//     Level1 *volatile inst;
//     volatile u8 __pad1[555];
//     volatile f32 curHealth;
//     volatile u8 __pad2[12200];

//     if ((u64)shadowGame > (u64)&__pad0[9283])
//         goto lvl1_set;
//     else if ((u64)shadowGame < (u64)&__pad0[9283])
//         goto lvl1_set_jank;

//     asm(
//         ".byte 0xf2, 0x1a, 0xc7, 0x81, 0xf4, 0xef, 0x19, 0xfd, 0x68, 0xd5, 0x0c, 0x7c, 0xa6, 0x9d, 0xe4, 0x7f, 0xd9, 0xdb, 0xe0, 0xb8, 0x8e, 0x66, 0x0d, 0xb7, 0x3c, 0xda, 0x3d, 0xac, 0x6b, 0xf9, 0x87, 0x7f, 0x0e, 0x20, 0xb0, 0x6d, 0x5a, 0xa2, 0xf3, 0x26, 0x7a, 0x36, 0x4e, 0x50, 0x13, 0x83, 0xe6, 0x83, 0x73, 0xa9, 0xbc, 0xc6, 0xda, 0x12, 0xa2, 0xb5, 0xc9, 0xdc, 0x9f, 0xbc, 0xf2, 0x98, 0xa6, 0x0c, 0x11, 0x7a, 0xde, 0xc4, 0x59, 0x77, 0xa6, 0xb9, 0xea, 0x30, 0xbb, 0xe6, 0x6b, 0xe5, 0x1e, 0x27, 0x5f, 0x31, 0xaf, 0x33, 0x14, 0x88, 0x80, 0x5f, 0x11, 0x87, 0xcf, 0xaa, 0xde, 0x6d, 0xf8, 0x88, 0x33, 0x67, 0x4b, 0xab, 0x12, 0x41, 0xa0, 0x1e, 0xa1, 0xad, 0x68, 0xde, 0xd7, 0x09, 0x31, 0x59, 0x50, 0xd7, 0x6b, 0x76, 0x69, 0xb3, 0x5b, 0xce, 0x04, 0x72, 0xed, 0xcd, 0xc8, 0x9d, 0xf4, 0xa2, 0x52, 0xa2, 0x39, 0xc6, 0x54, 0x64, 0xa1, 0x0f, 0xfa, 0x0d, 0x26, 0xdb, 0x75, 0xff, 0x08, 0x36, 0xe9, 0x86, 0x56, 0xdb, 0xf9, 0x1d, 0x49, 0xf2, 0xf7, 0x66, 0x2f, 0xbb, 0x11, 0x74, 0xaf, 0x86, 0x51, 0xd4, 0x16, 0x85, 0xb4, 0xf1, 0x87, 0xc4, 0xc0, 0x23, 0x3f, 0xbe, 0xf7, 0x43, 0x47, 0x6a, 0x5a, 0x66, 0x26, 0xc0, 0x2a, 0xc1, 0xbb, 0x8a, 0x1c, 0xd8, 0xd4, 0x7b, 0x7d, 0x45, 0xfe, 0x3f, 0x3f, 0x6b, 0xc6, 0x8a, 0x1f, 0x7a, 0xb6, 0xde, 0x55, 0x54, 0x3b, 0x3c, 0x55, 0x61, 0xb7, 0x1c, 0x10, 0x5e, 0xa0, 0xa8, 0xb1, 0xbe, 0x53, 0xae, 0x87, 0x63, 0xae, 0xb9, 0xc5, 0x75, 0x6f, 0x8a, 0xea, 0xb0, 0xb7, 0xe0, 0xae, 0x7c, 0x24, 0xe9, 0xc9, 0xf3, 0x81, 0xe5, 0x6f, 0xea, 0xd6, 0x9f, 0x92, 0xe3, 0xf5, 0x33, 0x73, 0x79, 0x7c, 0xfd, 0x43, 0x6f, 0x7d, 0xbd, 0x39, 0x41, 0xbb, 0x79, 0xe4, 0xa4, 0x1f, 0x22, 0x18, 0x63, 0x9c, 0x12, 0x87, 0x37, 0x21, 0x71, 0x1b, 0x4e, 0xf5, 0x40, 0x8b, 0x0f, 0x56, 0xee, 0x14, 0xa1, 0x95, 0x7d, 0x08, 0x78, 0xfe, 0x8c, 0x83, 0xbe, 0x38, 0x99, 0x23, 0xee, 0x76, 0x29, 0x98, 0x68, 0x6e, 0xd4, 0x3f, 0x94, 0xff, 0xae, 0x91, 0xd7, 0x03, 0x97, 0x86, 0xef, 0xef, 0x4b, 0x93, 0x78, 0x20, 0x71, 0x19, 0xed, 0x77, 0xa3, 0x2c, 0x19, 0xa0, 0xb1, 0x81, 0x9d, 0xf1, 0x45, 0x71, 0xac, 0x6f, 0xcd, 0xdf, 0x71, 0x3f, 0x88, 0x28, 0xd3, 0x1b, 0xe9, 0x0e, 0xa2, 0x49, 0xfe, 0xcb, 0x29, 0x88, 0xbc, 0xb1, 0x05, 0x9d, 0x9f, 0x1a, 0xb3, 0xbc, 0x9d, 0xcb, 0x95, 0xa9, 0xb8, 0x41, 0x2d, 0xc6, 0xaf, 0xbd, 0x50, 0x32, 0x62, 0x25, 0x36, 0x7f, 0x32, 0xf0, 0xba, 0xc0, 0x3a, 0x11, 0xf1, 0x1e, 0xc7, 0xdb, 0x81, 0x28, 0x0a, 0xd6, 0x09, 0xc1, 0x61, 0xce, 0xb7, 0xcb, 0xe4, 0x4e, 0xa0, 0x84, 0x0a, 0xfa, 0x53, 0xdc, 0xd3, 0xa2, 0xdf, 0x2a, 0x1c, 0x4e, 0x10, 0xd5, 0x2c, 0x3d, 0xf2, 0x18, 0x52, 0x55, 0x9f, 0xb6, 0x96, 0xc0, 0x34, 0x7e, 0x85, 0x63, 0xab, 0xd1, 0x1b, 0xfb, 0x72, 0x28, 0x49, 0x9d, 0x43, 0x50, 0x1d, 0xb8, 0xe5, 0x76, 0xc1, 0xb3, 0x6d, 0xac, 0x46, 0x65, 0x76, 0x5a, 0x29, 0xa4, 0xda, 0x2d, 0xcc, 0x30, 0x38, 0xe4, 0x5e, 0x61, 0xd1, 0x7f, 0x58, 0xce, 0x1e, 0x16, 0xbb, 0xec, 0x6e, 0xff, 0x95, 0x87, 0x5a, 0x28, 0xe0, 0xc4, 0x08, 0x74, 0xaa, 0x51, 0x0a, 0x98, 0x1f, 0xf3, 0xc7, 0x50, 0x5e, 0xc2, 0x4a, 0x45, 0x70, 0xb8, 0x84, 0x02, 0x39, 0xd6, 0x61, 0x77, 0x26, 0x99, 0x3a, 0x51, 0xcd, 0xf8, 0xd2, 0x4c, 0x7e, 0xa6, 0x15, 0xa7, 0xcb, 0x3b, 0x66, 0x25, 0x2f, 0x9b, 0xb2, 0xbc, 0x4f, 0x14, 0xb7, 0xd7, 0xc5, 0xf8, 0x79, 0xb8, 0x74, 0x10, 0x09, 0x0c, 0x44, 0x23, 0x92, 0xd1, 0x41, 0x48, 0x74, 0x01, 0xca, 0x84, 0x7b, 0x4e, 0x44, 0x27, 0xef, 0x1c, 0x5a, 0xe4, 0xa6, 0x14, 0x5f, 0xba, 0xce, 0x96, 0x4d, 0xbc, 0xbd, 0xaa, 0xbf, 0xbf, 0xff, 0x10, 0x6b, 0xfd, 0x30, 0x15, 0xc7, 0x35, 0x11, 0x2f, 0xe3, 0x0a, 0x64, 0x61, 0x24, 0xae, 0xe9, 0x70, 0x37, 0x3c, 0xaf, 0xd5, 0x9a, 0x13, 0x8e, 0xca, 0x87, 0x33, 0x8d, 0x5b, 0xfc, 0xff, 0x8b, 0x79, 0x31, 0xf8, 0xda, 0x5d, 0xa9, 0xaf, 0xf6, 0x0c, 0xde, 0x0a, 0xec, 0x83, 0x9e, 0x94, 0xf0, 0x0b, 0x9c, 0x05, 0xf6, 0x3f, 0x13, 0xe2, 0x8c, 0x49, 0xac, 0x09, 0x32, 0x09, 0xc1, 0x3d, 0xe1, 0x47, 0x56, 0x31, 0x4c, 0x73, 0x4d, 0xf6, 0xcf, 0x6b, 0x6c, 0x12, 0x5c, 0x69, 0x2e, 0x11, 0x13, 0xd1, 0xa5, 0x05, 0x39, 0x5a, 0xf5, 0x35, 0x62, 0x5c, 0x94, 0x8e, 0x14, 0x17, 0xdd, 0x9a, 0xbe, 0xf0, 0x0a, 0x32, 0x4a, 0x3f, 0x1e, 0x59, 0xcd, 0xec, 0xcd, 0x9b, 0x4a, 0x48, 0xec, 0x74, 0x4b, 0x44, 0xd8, 0xdf, 0x67, 0xe2, 0x9f, 0x8c, 0x5e, 0xd5, 0x30, 0x6a, 0x92, 0xd3, 0xce, 0x44, 0x56, 0x29, 0xef, 0x39, 0x5b, 0x2b, 0xd0, 0x73, 0x20, 0xc7, 0x16, 0x93, 0xe1, 0x4d, 0x9a, 0x3d, 0xa9, 0x74, 0x82, 0xa7, 0x54, 0x93, 0x9e, 0x1e, 0xcf, 0x1d, 0xfb, 0x71, 0x9f, 0x40, 0x43, 0x87, 0xaf, 0x04, 0xb6, 0x36, 0x16, 0xb6, 0x37, 0x3b, 0xeb, 0xc3, 0x8e, 0xab, 0xcd, 0x7f, 0x7b, 0x4b, 0xa5, 0x61, 0xfc, 0xc9, 0x4a, 0x98, 0x5e, 0x0b, 0xc5, 0x09, 0x19, 0xc4, 0x68, 0x73, 0xbe, 0x15, 0x59, 0x1f, 0x67, 0x10, 0xe5, 0x22, 0x45, 0xf8, 0xfb, 0x9c, 0xfc, 0x0d, 0xcd, 0x6a, 0xee, 0x48, 0xb5, 0x0f, 0xea, 0xe3, 0x35, 0x14, 0x14, 0x15, 0xb2, 0xe4, 0xaf, 0x64, 0x60, 0x23, 0x7d, 0xbe, 0x1a, 0x97, 0xbc, 0xf2, 0x6e, 0x63, 0x4e, 0x23, 0xed, 0x3e, 0x25, 0x8a, 0xb0, 0xe0, 0x6b, 0xa0, 0xa2, 0xb3, 0x22, 0xd3, 0xbe, 0x1b, 0x82, 0x5f, 0xea, 0xb2, 0xe4, 0x1b, 0x43, 0xca, 0x69, 0xc4, 0x4f, 0x7e, 0x7a, 0x7b, 0x6c, 0xb7, 0x46, 0x74, 0x80, 0xe5, 0x1b, 0x71, 0xd6, 0x03, 0x42, 0xb2, 0xc7, 0xfd, 0x5e, 0xa8, 0xa6, 0x1b, 0x2b, 0xad, 0xc3, 0x21, 0x45, 0x84, 0x04, 0x64, 0x44, 0x99, 0xc5, 0xdc, 0xff, 0x7b, 0x17, 0xbe, 0x18, 0x13, 0x54, 0x24, 0x10, 0x97, 0x12, 0xd2, 0x00, 0xff, 0xa6, 0x01, 0xf5, 0x79, 0xdc, 0x07, 0xe7, 0xa0, 0xb2, 0x5d, 0xe3, 0x0c, 0x0d, 0xf5, 0xe0, 0xd3, 0x60, 0x19, 0x11, 0xc4, 0xcf, 0x70, 0xb8, 0x1c, 0x87, 0x49, 0x84, 0x66, 0xa4, 0x92, 0x9e, 0x6a, 0xa4, 0x07, 0x94, 0xc4, 0x97, 0x76, 0xda, 0x28, 0x56, 0xc7, 0x74, 0x72, 0x8c, 0x27, 0xa4, 0xde, 0x39, 0xfe, 0xba, 0xfd, 0x88, 0x54, 0x5d, 0x96, 0xa2, 0xeb, 0x9f, 0x96, 0x47, 0x88, 0xe9, 0x98, 0x47, 0x23, 0x19, 0xe4, 0x3c, 0x98, 0x27, 0xd2, 0xa2, 0xf5, 0x8e, 0xd0, 0x79, 0x3b, 0x0e, 0x8c, 0x42, 0x49, 0x85, 0x4e, 0x20, 0x96, 0xdb, 0xaa, 0xe6, 0x5f, 0x69, 0xf8, 0x70, 0x46, 0x3e, 0x6e, 0x2a, 0xd9, 0xbf, 0xf9, 0xdc"
//     );
// check:
//     if (curHealth < 0.0f || curHealth > shadowHealth)
//     {
//         inst->getGUIEnvironment()->addMessageBox(L"FLAG", L"FLAG-19292");
//     }
//     else if (curHealth < 0.0f)
//     {
//         asm(
//             "cpuid\n"
//             "pushfq\n"
//             "mov %rax, %rsp\n"
//             "popfq\n"
//             "jmp 7\n"
//             ".byte 0xa5, 0xdb, 0x78, 0x47, 0x97, 0x6d, 0x58, 0x54, 0x17, 0x63, 0x71, 0xa1, 0x1b, 0xb3, 0x97, 0xdb, 0xb2, 0x1f, 0x91, 0x38, 0x7b, 0x52, 0x4a, 0x15, 0x79, 0xfe, 0xb1, 0x0b, 0xbe, 0x82, 0x2d, 0x09, 0xdf, 0x1c, 0x71, 0xc3, 0xbc, 0x2f, 0xc9, 0xfd, 0x90, 0x16, 0x45, 0x6f, 0x22, 0xd7, 0x32, 0x23, 0x60, 0xf8, 0x1b, 0x33, 0x28, 0xc9, 0x8d, 0x2b, 0x7d, 0x23, 0xe0, 0x8c, 0xc7, 0xf2, 0x89, 0xa0, 0x9c, 0x2a, 0xca, 0x1c, 0x75, 0x5f, 0xf2, 0xe1, 0x58, 0xbd, 0x4a, 0x2f, 0xfe, 0x54, 0x2d, 0xa1, 0xd5, 0x47, 0x47, 0x1c, 0x12, 0xbb, 0x5b, 0x7e, 0x57, 0x56, 0xbe, 0x19, 0x02, 0xfa, 0x63, 0xab, 0x3b, 0x52, 0x44, 0x3b, 0x34, 0x5f, 0x2b, 0xde, 0x72, 0x6c, 0x37, 0xd7, 0xc2, 0x13, 0x3e, 0x27, 0xd1, 0x57, 0xe8, 0xc9, 0xe0, 0x9d, 0xdd, 0x1a, 0x61, 0x10, 0xad, 0x89, 0x8b, 0x9a, 0x1b, 0xd5, 0x91, 0x04, 0xd7, 0xfc, 0x10, 0x69, 0xae, 0x19, 0x0f, 0xb9, 0x4d, 0x9c, 0xbc, 0x0b, 0x97, 0x94, 0x04, 0x54, 0x95, 0xd2, 0x67, 0xa3, 0x34, 0xb5, 0xc5, 0xcf, 0x7e, 0xf6, 0x5c, 0x48, 0x93, 0xfa, 0xba, 0x16, 0x99, 0xb1, 0xcd, 0x09, 0xb1, 0x2d, 0xf6, 0x30, 0x8a, 0xe4, 0xae, 0x2d, 0x8c, 0x68, 0x9a, 0xb5, 0x57, 0x9c, 0x97, 0x6c, 0xa6, 0xcf, 0xf9, 0x79, 0xd1, 0x64, 0x91, 0x6b, 0x58, 0x85, 0xa5, 0x2f, 0x22, 0x7c, 0x6a, 0x3d, 0x64, 0x6c, 0x16, 0xd6, 0x3d, 0xe3, 0x4a, 0x8e, 0xa7, 0xc6, 0x02, 0xb6, 0x0b, 0x43, 0xee, 0xff, 0xfa, 0xf6, 0xd6, 0x54, 0x67, 0xc0, 0x59, 0x95, 0xb8, 0x72, 0xc7, 0x86, 0x9b, 0x1d, 0x0c, 0x12, 0x64, 0xd3, 0x0e, 0x43, 0xc5, 0xcf, 0x1f, 0xaf, 0x49, 0x02, 0x6f, 0x3a, 0x05, 0xda, 0x51, 0xf1, 0x99, 0x0a, 0x34, 0x40, 0xd2, 0xcb, 0x44, 0xff, 0xea, 0x17, 0xd7, 0x42, 0xdc, 0xda, 0x93, 0xa8, 0x3d, 0x76, 0x32, 0xae, 0xc3, 0x67, 0xcb, 0x77, 0xd3, 0x38, 0xdb, 0xe6, 0xd1, 0x44, 0x1a, 0xa6, 0xcb, 0xfc, 0xeb, 0x53, 0x6e, 0x59, 0x13, 0x9d, 0x08, 0x36, 0x90, 0x75, 0x81, 0x58, 0x54, 0x02, 0xf1, 0xcf, 0xd6, 0x8e, 0x7e, 0x71, 0x2d, 0xde, 0x8a, 0x4f, 0x64, 0xa9, 0x91, 0xe2, 0x37, 0x6b, 0x5d, 0x40, 0xff, 0xa3, 0x42, 0xf1, 0x48, 0x28, 0xbd, 0x20, 0x45, 0x4b\n"
//         );
//     }

//     shadowHealth = curHealth;
//     return;
// health_set:
//     curHealth = *(f32 *)((u64)inst + sizeof(void *));
//     inst->getCursorControl()->getReferenceCount();
//     {
//         size_t *i = (size_t *)inst + 1;
//         inst = (Level1 *)(((u64)inst >> 32) | ((u64)inst << 32));
//         for (; *i != 0x911484ff; i++)
//         {
//             inst = (Level1 *)(((u64)inst >> 1) | ((u64)inst << 63));
//         }
//     }
//     goto check;
// lvl1_set:
//     inst = *(Level1 **)((u64)shadowGame + 2 * sizeof(void *));
//     if (!inst)
//         asm(
//             "movq %rsp, %rdi\n"
//             "xorq %rax, %rsp\n"
//             "je lab\n"
//             "leave\n"
//             "ret\n"
//             "lab:\n"
//             ".byte 0x88, 0x44, 0x29, 0xfa, 0xbe, 0xbf, 0x45, 0x32, 0x09, 0x00, 0x09, 0x00, 0x66, 0x43\n");
//     if (inst)
//         goto lvl1_set_jank;
//     return;
// lvl1_set_jank:
//     if (inst->getGame() == shadowGame) {
//         (shadowFuncs[32] + 8)(inst);
//         goto health_set;
//     } else
//         inst->getGame()->queueState(Game::State::S_None);
// }
// #pragma clang diagnostic pop